function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { throwError } from "@jimp/utils";
import { ensureInteger, getAddonReleaseVersion, cppCallbackWrapper, wrapAsync } from "@jimp-native/utils-ts";
var addon = require("../build/".concat(getAddonReleaseVersion(), "/plugin-rotate-napi.node"));
function rotate(degrees, resize, cb) {
  if (typeof resize === "undefined" || resize === undefined) {
    resize = true;
  }
  if (typeof resize === "function" && typeof cb === "undefined") {
    cb = resize;
    resize = true;
  }
  if (typeof resize !== "boolean" && typeof resize !== "string") {
    return throwError.call(this, "Resize must be of type Boolean or String", cb);
  }
  try {
    var _this$bitmap = this.bitmap,
      width = _this$bitmap.width,
      height = _this$bitmap.height;

    // Clone the current image data to a new Jimp instance.
    var originalImage = new this.constructor(0, 0);
    originalImage.bitmap = _objectSpread({}, this.bitmap);

    // If resize is not permitted, just go straight to advancedRotate in place
    if (!resize) {
      addon.advancedRotate(this.bitmap.data, this.bitmap.width, this.bitmap.height, degrees, cppCallbackWrapper(this, cb));
      return this;
    }

    // If we can rotate by a multiple of 90 degrees, use a simplified matrix rotation method.
    if (degrees % 90 === 0) {
      // Ensure degrees is within a range C++ can work with.
      degrees %= 360;
      switch (degrees) {
        case 0:
          degrees = 0;
          break;
        case 90:
        case -270:
          degrees = 90;
          break;
        case 180:
        case -180:
          degrees = 180;
          break;
        default:
          degrees = 270;
      }
      if (degrees === 0) {
        if (cb) {
          cb.call(this, null, this);
        }
        return this;
      }
      var originalBitmap = this.bitmap.data;
      var newWidth = degrees % 180 === 0 ? width : height;
      var newHeight = degrees % 180 === 0 ? height : width;
      var newBuffer = Buffer.alloc(newWidth * newHeight * 4);
      this.bitmap.data = newBuffer;
      this.bitmap.width = newWidth;
      this.bitmap.height = newHeight;
      addon.matrixRotate(originalBitmap, width, height, newBuffer, newWidth, newHeight, degrees, cppCallbackWrapper(this, cb));
      return this;
    }

    /**
     * No shortcuts left to try, calculate new size in JS, create an image of the right size and pass it onto
     * advancedRotate
     */
    var radians = degrees * Math.PI / 180;
    var cosine = Math.cos(radians);
    var sine = Math.sin(radians);
    width = Math.ceil(Math.abs(originalImage.getWidth() * cosine) + Math.abs(originalImage.getHeight() * sine)) + 1;
    height = Math.ceil(Math.abs(originalImage.getWidth() * sine) + Math.abs(originalImage.getHeight() * cosine)) + 1;
    if (width % 2 !== 0) {
      width++;
    }
    if (height % 2 !== 0) {
      height++;
    }
    var newWidthHeight = ensureInteger(Math.max(width, height, originalImage.getWidth(), originalImage.getHeight()));
    this.bitmap.data = Buffer.alloc(newWidthHeight * newWidthHeight * 4);
    this.bitmap.width = newWidthHeight;
    this.bitmap.height = newWidthHeight;
    var self = this;
    if (typeof self.crop !== "function") {
      return throwError.call(self, new Error("A version of plugin-crop must be loaded in order to use resizing with rotate"), cb);
    }
    if (typeof self.blit !== "function") {
      return throwError.call(self, new Error("A version of plugin-blit must be loaded in order to use resizing with rotate"), cb);
    }
    if (cb) {
      // If we're running in async mode then we'll need to chain these properly through callbacks.
      var doCrop = function doCrop() {
        self.crop(ensureInteger(self.bitmap.width / 2 - width / 2), ensureInteger(self.bitmap.height / 2 - height / 2), width, height, function (err) {
          if (err) {
            return throwError.call(self, err, cb);
          }
          cb.call(self, null, self);
        });
      };
      var doRotate = function doRotate() {
        addon.advancedRotate(self.bitmap.data, self.bitmap.width, self.bitmap.height, degrees, function (err) {
          if (err) {
            return throwError.call(self, err, cb);
          }
          doCrop();
        });
      };
      self.blit(originalImage, ensureInteger(self.bitmap.width / 2 - originalImage.getWidth() / 2), ensureInteger(self.bitmap.height / 2 - originalImage.getHeight() / 2), 0, 0, originalImage.getWidth(), originalImage.getHeight(), function (err) {
        if (err) {
          return throwError.call(self, err, cb);
        }
        doRotate();
      });
    } else {
      self.blit(originalImage, ensureInteger(self.bitmap.width / 2 - originalImage.getWidth() / 2), ensureInteger(self.bitmap.height / 2 - originalImage.getHeight() / 2), 0, 0, originalImage.getWidth(), originalImage.getHeight());
      addon.advancedRotate(self.bitmap.data, self.bitmap.width, self.bitmap.height, degrees);
      self.crop(ensureInteger(this.bitmap.width / 2 - width / 2), ensureInteger(this.bitmap.height / 2 - height / 2), width, height);
    }
  } catch (err) {
    return throwError.call(this, err, cb);
  }
}
var plugin = function plugin() {
  return {
    rotate: rotate,
    rotateAsync: wrapAsync(rotate)
  };
};
export default plugin;
//# sourceMappingURL=index.js.map