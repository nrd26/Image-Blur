"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = require("@jimp/utils");
var _utilsTs = require("@jimp-native/utils-ts");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var addon = require("../build/".concat((0, _utilsTs.getAddonReleaseVersion)(), "/plugin-crop-napi.node"));
var crop = function crop(x, y, w, h, _cb) {
  var self = this;
  try {
    x = Math.max((0, _utilsTs.ensureInteger)(x), 0);
    y = Math.max((0, _utilsTs.ensureInteger)(y), 0);
    w = Math.min((0, _utilsTs.ensureInteger)(w), self.getWidth());
    h = Math.min((0, _utilsTs.ensureInteger)(h), self.getHeight());
    var updateBitmap = function updateBitmap() {
      self.bitmap.data = self.bitmap.data.slice(0, w * h * 4);
      self.bitmap.width = w;
      self.bitmap.height = h;
    };
    var skip = x === 0 && y === 0 && w === self.getWidth();
    if (skip) {
      // If X and Y is zero and w is the full image width then we can just cut the buffer to size.
      updateBitmap();
      if (typeof _cb === "function") {
        _cb.call(self, null, self);
      }
      return self;
    }
    var prependUpdate = typeof _cb === "function";
    if (prependUpdate) {
      var originalCallback = _cb;
      // Ensures updateBitmap gets called before the image gets to user code.
      _cb = function cb(err) {
        if (err) {
          return _utils.throwError.call(self, err, _cb);
        }
        updateBitmap();
        originalCallback.call(self, null, self);
      };
    }
    addon.crop(self.bitmap.data, self.getWidth(), self.getHeight(), x, y, w, h, (0, _utilsTs.cppCallbackWrapper)(self, _cb));
    if (!prependUpdate) {
      updateBitmap();
    }
    return self;
  } catch (err) {
    return _utils.throwError.call(this, err, _cb);
  }
};
var autocrop = function autocrop() {
  var _this = this;
  var arg1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var arg2 = arguments.length > 1 ? arguments[1] : undefined;
  var arg3 = arguments.length > 2 ? arguments[2] : undefined;
  var cb;
  var leaveBorder = 0;
  var tolerance = 0.0002;
  var cropOnlyFrames = true;
  var symmetric = false;
  var north = true;
  var east = true;
  var south = true;
  var west = true;
  if (_typeof(arg1) === "object") {
    var _arg1$tolerance, _arg1$leaveBorder, _arg1$cropOnlyFrames, _arg1$cropSymmetric, _arg1$ignoreSides, _arg1$ignoreSides2, _arg1$ignoreSides3, _arg1$ignoreSides4;
    tolerance = (_arg1$tolerance = arg1 === null || arg1 === void 0 ? void 0 : arg1.tolerance) !== null && _arg1$tolerance !== void 0 ? _arg1$tolerance : tolerance;
    leaveBorder = (_arg1$leaveBorder = arg1 === null || arg1 === void 0 ? void 0 : arg1.leaveBorder) !== null && _arg1$leaveBorder !== void 0 ? _arg1$leaveBorder : leaveBorder;
    cropOnlyFrames = (_arg1$cropOnlyFrames = arg1 === null || arg1 === void 0 ? void 0 : arg1.cropOnlyFrames) !== null && _arg1$cropOnlyFrames !== void 0 ? _arg1$cropOnlyFrames : cropOnlyFrames;
    symmetric = (_arg1$cropSymmetric = arg1 === null || arg1 === void 0 ? void 0 : arg1.cropSymmetric) !== null && _arg1$cropSymmetric !== void 0 ? _arg1$cropSymmetric : symmetric;
    north = !(arg1 !== null && arg1 !== void 0 && (_arg1$ignoreSides = arg1.ignoreSides) !== null && _arg1$ignoreSides !== void 0 && _arg1$ignoreSides.north);
    east = !(arg1 !== null && arg1 !== void 0 && (_arg1$ignoreSides2 = arg1.ignoreSides) !== null && _arg1$ignoreSides2 !== void 0 && _arg1$ignoreSides2.east);
    south = !(arg1 !== null && arg1 !== void 0 && (_arg1$ignoreSides3 = arg1.ignoreSides) !== null && _arg1$ignoreSides3 !== void 0 && _arg1$ignoreSides3.south);
    west = !(arg1 !== null && arg1 !== void 0 && (_arg1$ignoreSides4 = arg1.ignoreSides) !== null && _arg1$ignoreSides4 !== void 0 && _arg1$ignoreSides4.west);
  }
  if (typeof arg1 === "number") {
    tolerance = arg1;
  }
  if (typeof arg1 === "boolean") {
    cropOnlyFrames = arg1;
  }
  if (typeof arg2 === "boolean") {
    cropOnlyFrames = arg2;
  }
  if (typeof arg1 === "function") {
    cb = arg1;
  }
  if (typeof arg2 === "function") {
    cb = arg2;
  }
  if (typeof arg3 === "function") {
    cb = arg3;
  }
  var updateBitmap = function updateBitmap() {
    _this.bitmap.data = _this.bitmap.data.slice(0, _this.bitmap.width * _this.bitmap.height * 4);
  };
  var prependUpdate = typeof cb === "function";
  if (prependUpdate) {
    var originalCallback = cb;

    // Ensures updateBitmap gets called before the image gets to user code.
    cb = function cb(err, image, newWidth, newHeight) {
      if (err) {
        return originalCallback.call(this, err, null);
      }
      this.bitmap.width = newWidth;
      this.bitmap.height = newHeight;
      updateBitmap();
      originalCallback.call(this, null, this);
    };
    cb.bind(this);
  }
  try {
    addon.autocrop(this.bitmap.data, this.getWidth(), this.getHeight(), (0, _utilsTs.ensureInteger)(leaveBorder), tolerance, cropOnlyFrames, symmetric, north, east, south, west, this.bitmap, (0, _utilsTs.cppCallbackWrapper)(this, cb));
    if (!prependUpdate) {
      updateBitmap();
    }
    return this;
  } catch (err) {
    return _utils.throwError.call(this, err, cb);
  }
};
var plugin = function plugin() {
  return {
    crop: crop,
    cropAsync: (0, _utilsTs.wrapAsync)(crop),
    autocrop: autocrop,
    autocropAsync: (0, _utilsTs.wrapAsync)(autocrop)
  };
};
var _default = plugin;
exports["default"] = _default;
module.exports = exports.default;
//# sourceMappingURL=index.js.map